{
    "simple": [
        {
          "question_id": 9,
          "db_id": "california_schools",
          "question": "Among the schools with the average score in Math over 560 in the SAT test, how many schools are directly charter-funded?",
          "evidence": "",
          "SQL": "SELECT COUNT(T2.`School Code`) FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrMath > 560 AND T2.`Charter Funding Type` = 'Directly funded'",
          "difficulty": "simple",
          "question_enriched": "Please find the number of schools (COUNT(frpm.`School Code`)) whose charter funding type is directly funded (frpm.`Charter Funding Type` = 'Directly funded'), and whose AvgScrMath larger than 560 in the SAT test (satscores.AvgScrMath > 560).",
          "question_enriched_v2": "Please find the number of schools (COUNT(frpm.`School Code`)) whose charter funding type is directly funded (frpm.`Charter Funding Type` = 'Directly funded'), and whose AvgScrMath larger than 560 in the SAT test (satscores.AvgScrMath > 560). \n To find the schools with the charter funding type information and average math score in SAT, frpm and satscores tables should be joined. \n Apply the charter funding type condition (frpm.`Charter Funding Type` = 'Directly funded') and average math score condition(satscores.AvgScrMath > 560). \n Calculate the  number of schools using COUNT aggregate function in the Select statement.",
          "enrichment_reasoning": "The information of wheter a school is directly or locally funded or not can be found from the 'Charter Funding Type' column of the frpm table in the database. \n The information of average score in Math in SAT test of schools can be found from the AvgScrMath column of the satscores table in the database. \n It is asked to find the number of schools whose average score in Math over 560 in the SAT test and that are directly charter-funded. \n To find the schools that holds asked conditions can be find by joining the frpm and satscores tables in SQL statement. \n After applying the average math score conditioin (satscores.AvgScrMath > 560) and funding type condition (frpm.`Charter Funding Type` = 'Directly funded'), School Codes should be counted with COUNT aggregate function."
        },
        {
          "question_id": 64,
          "db_id": "california_schools",
          "question": "What is the total number of schools with a mailing city in Hickman belonging to the charter number 00D4?",
          "evidence": "",
          "SQL": "SELECT COUNT(*) FROM schools WHERE CharterNum = '00D4' AND MailCity = 'Hickman'",
          "difficulty": "simple",
          "question_enriched": "PPlease find the number of schools (COUNT(*)) whose mailing city is Hickman (schools.MailCity = 'Hickman') and charter school number is 00D4 (schools.CharterNum = '00D4').",
          "question_enriched_v2": "Please find the number of schools (COUNT(*)) whose mailing city is Hickman (schools.MailCity = 'Hickman') and charter school number is 00D4 (schools.CharterNum = '00D4'). \n Apply mailing city condition (schools.MailCity = 'Hickman') on schools table and charter number condition (schools.CharterNum = '00D4') on school table. \n Count number of entities using COUNT aggregate functioin (COUNT(*)).",
          "enrichment_reasoning": " The mailing city information of a schools can be found from the MailCity column of the schools table in the database.\n The charter number information of schools can be found from the CharterNum column of the schools table in the database. \n It is asked to find the number of shcools whose mailing city is Hickman and charter number is 00D4. \n Since all the required information can be found from a single table, there is no need for joining tables. \n After applying the mailing city condition (schools.MailCity = 'Hickman') on schools table and the charter number condition (schools.CharterNum = '00D4') on schools table, the number of school should be count using COUNT aggregate function."
        },
        {
          "question_id": 343,
          "db_id": "card_games",
          "question": "Name all cards with 2015 frame style ranking below 100 on EDHRec.",
          "evidence": "below 100 on EDHRec refers to EDHRec <100; with 2015 frame style refers to frameVersion = 2015;",
          "SQL": "SELECT id FROM cards WHERE edhrecRank < 100 AND frameVersion = 2015",
          "difficulty": "simple",
          "question_enriched": "Please find the card ids of cards whose frame style is 2015 (frameVersion = 2015) and EDHRec ranking is below 100 (edhrecRank < 100).",
          "question_enriched_v2": "Please find the card ids of cards whose frame style is 2015 (frameVersion = 2015) and EDHRec ranking is below 100 (edhrecRank < 100).\n The conditions (edhrecRank < 100 and frameVersion = 2015) should be applied on the cards table and id of the cards should be selected.",
          "enrichment_reasoning": "The information of frame style can be found from the frameVersion column of the cards table in the database.\n The information of whether a card ranking is below 100 or not can be found from EDHRec column edhrecRank of the cards table in the database.\n Conditions (edhrecRank < 100 and frameVersion = 2015) should be applied on the cards table and id of the cards should be selected."
        },
        {
          "question_id": 616,
          "db_id": "codebase_community",
          "question": "What is the comment's rating score of the post which was created on 7/19/2010 7:19:56 PM",
          "evidence": "created on 7/19/2010 7:19:56 PM refers to CreationDate = '2010-07-19 19:19:56.0'",
          "SQL": "SELECT T1.Score FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.CreationDate = '2010-07-19 19:19:56.0'",
          "difficulty": "simple",
          "question_enriched": "Please find the score of the comment of the post whose creationDate is '2010-07-19 19:19:56.0' (CreationDate = '2010-07-19 19:19:56.0').",
          "question_enriched_v2": "Please find the score of the comment of the post whose creationDate is '2010-07-19 19:19:56.0' (CreationDate = '2010-07-19 19:19:56.0').\n The condition (posts.CreationDate = '2010-07-19 19:19:56.0') should be applied after joining posts and comments tables. Then, score column in the comments table should be selected.",
          "enrichment_reasoning": "Post creating information can be found from the CreaionDate column of the posts table in the database. \n Comment's rating score information can be found from the Score column of the comments table. \n It is asked to find rating score of the comment made for the post created on '2010-07-19 19:19:56.0'.\n Joining the posts and comments table is required to match the comments with corresponding post.\n After appying the condition (posts.CreationDate = '2010-07-19 19:19:56.0') on the posts table, Score column should be selected."
        },
        {
          "question_id": 1496,
          "db_id": "debit_card_specializing",
          "question": "Which client segment consumed the least in September 2013?",
          "evidence": "September 2013 refers to yearmonth.date = '201309'",
          "SQL": "SELECT T1.Segment FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201309' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
          "difficulty": "simple",
          "question_enriched": "Please find the customer segment(customers.Segment) with the lowest consumption in September 2013 (yearmonth.Date = '201309'). Single entity(row) should be returned.",
          "question_enriched_v2": "Please find the customer segment(customers.Segment) with the lowest consumption in September 2013 (yearmonth.Date = '201309'). Single entity(row) should be returned.\nThe customer and yearmonth tables should be joined to find each customers consumption for a given date. After the condition (yearmonth.Date = '201309') is applied, entities should be grouped by customer segments (customers.Segment) and ordered in ascendingly.\nLimiting the returned entity as 1 and selecting Segment column in the customers table will give the customer segment consumed the least in September 2013.",
          "enrichment_reasoning": "Client segment information can be found from the Segment column of the customers table in the database.\n Consumption information of a customer can be found from the Consumption column of the yearmonth table in the database.\n Asked month and year can be found in the Date column of the yearmonth table in the database as (yearmonth.Date = '201309').\n It is asked to find the customer segment (customers.Segment) whose consumption is lowest in September 2013 (yearmonth.Date = '201309').\n The customers and yearmonth tables should be joined to find each customers consumption for a period of time. Tables can be joined on CustomerID.\nAfter the condition (yearmonth.Date = '201309') is applied, entities should be grouped by customer segments (customers.Segment) and ascendingly ordered according to the sum of consumption (SUM(T2.Consumption)).\n Limiting the returned entity as 1 and selecting Segment column in the customers table will give the customer segment consumed the least in September 2013."
        },
        {
          "question_id": 1072,
          "db_id": "european_football_2",
          "question": "What is the average overall rating of the football player Aaron Doran?",
          "evidence": "average overall rating = AVG(overall_rating);",
          "SQL": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Aaron Doran'",
          "difficulty": "simple",
          "question_enriched": "Please find the average overall rating (AVG(Player_Attributes.overall_rating)) of the football player whose name is Aaron Doran (Player.player_name = 'Aaron Doran').",
          "question_enriched_v2": "Please find the average overall rating (AVG(Player_Attributes.overall_rating)) of the football player whose name is Aaron Doran (Player.player_name = 'Aaron Doran').\n Join the Player and Player_Attributes tables based on player_api_id. Apply the name condition (Player.player_name = 'Aaron Doran') in the WHERE clause. Then, apply AVG aggregate funtion in SELECT clause on overall_rating column of the Player_Attributes table (AVG(Player_Attributes.overall_rating)).",
          "enrichment_reasoning": "The overall rating of a football player can be found from the overall_rating column of the Player_Attributes table in the database.\n The name of a player can be found from the player_name column of the Player table in the database. \n It is asked to find the average overall rating of the football player whose name is Aaron Doran. \n For a given football player name, its attributes can be found by joining the Player and Player_Attributes table. This joining should be performed based on the player_api_id since player_api_id column in Player_Attributes table refers to the player_api_id in Player table and they are unique for a player. \n The given condition (Player.player_name = 'Aaron Doran') should be applied, and then AVG aggregate funtion should be applied on overall_rating column of the Player_Attributes table (AVG(overall_rating))."
        },
        {
          "question_id": 104,
          "db_id": "financial",
          "question": "The transaction of 840 USD happened in 1998/10/14, when was this account opened?",
          "evidence": "",
          "SQL": "SELECT T1.date FROM account AS T1 INNER JOIN trans AS T2 ON T1.account_id = T2.account_id WHERE T2.amount = 840 AND T2.date = '1998-10-14'",
          "difficulty": "simple",
          "question_enriched": " Please find the opening date (account.date) of the account on which 840 USD (trans.amount = 840) happened in 1998/10/14 (trans.date = '1998-10-14').",
          "question_enriched_v2": " Please find the opening date (account.date) of the account on which 840 USD (trans.amount = 840) happened in 1998/10/14 (trans.date = '1998-10-14').\n Join the account and trans tables through account_id columns of both accoutn and trans tables. Apply the transaction date and amount (trans.date = '1998-10-14' and trans.amount = 840) conditions. Select the opening date of account (account.date).",
          "enrichment_reasoning": "The transactions can be found from the trans table in the database (trans).\n The amount of the transaction can be found from the amount column of the trans table in the database (trans.amount).\n The date of the transaction can be found from the date column of the trans table in the database (trans.date).\n The information about and account can be found from the account table in the database (account).\n The opening date of an account can be found from the date column of the account table in the database (account.date).\n It is asked to find the open date of the account on which 840 USD transaction happened in 1998/10/14.\n To match the transaction information and account information, it is required to join the account and trans tables through account_id columns of both accoutn and trans table.\n The transaction date and transaction amount conditions (trans.date = '1998-10-14' and trans.amount = 840) should be applied. \n Select the opening date of the corresponding account by selecting date column of the account table (account.date)."
        },
        {
          "question_id": 979,
          "db_id": "formula_1",
          "question": "What race number has the most finishers?",
          "evidence": "finisher refers to time is not null;",
          "SQL": "SELECT raceId FROM results GROUP BY raceId ORDER BY COUNT(time IS NOT NULL) DESC LIMIT 1",
          "difficulty": "simple",
          "question_enriched": "Please find the raceId (results.raceID) that has the most finishers (COUNT(results.time IS NOT NULL)).",
          "question_enriched_v2": "Please find the raceId (results.raceID) that has the most finishers (COUNT(results.time IS NOT NULL)).\n Group entities of the results table with respect to raceId column. Descendingly order the entities of the results table with respect to the count of finishers (COUNT(results.time IS NOT NULL)) after grouping the entities. Select the raceId column of the results table.",
          "enrichment_reasoning": "The race number refers to the raceId. Since the race with the most finishers is asked, results table in the database should be taken into consideration.\n The race number can be found from the raceId column of the results table in the database.\n The finishers refers to the time is not null for a driver in the results table in the database.\n It is asked to find the race number (raceId) which has the most number of finishers (time is not null).\n Entities in the results table should be grouped by raceId to see the results for each race in as a grouped. \n Since the race with most finishers asked, the entities should be ordered descendingly with respect to the number of time values that are not null for a raceId (ORDER BY COUNT(time IS NOT NULL)), and the limit should be applied to return the race with the most finishers (LIMIT 1).\n Selection of the raceId is required to return the race number."
        },
        {
          "question_id": 1333,
          "db_id": "student_club",
          "question": "What city and state did the President of the Student_Club grow up?",
          "evidence": "'President' is a position of Student Club;",
          "SQL": "SELECT T2.city, T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.position = 'President'",
          "difficulty": "simple",
          "question_enriched": "Please find the city (zip_code.city) and state (zip_code.state) of the member whose position is President (member.position = 'President').",
          "question_enriched_v2": "Please find the city (zip_code.city) and state (zip_code.state) of the member whose position is President (member.position = 'President').\n Join the member and the zip_code tables on zip column of member table and zip_code column of the zip_code table.\n Apply the member position condition (member.position = 'President'). Select the city (zip_code.city) and state (zip_code.state) columns of the zip_code table.",
          "enrichment_reasoning": "The president is a position of Studen Club and a president is a member. So, the position of a member can be found from the position column of the member table in the database.\n The zip refers to the place, and the zip column in member table refers to the place about a member. The zip references to zip_code column in the zip_code table in the database.\n The city and state information of a zip_code can be found from the city and state column of the zip_code table in the database.\n It is asked to find the city (zip_code.city) and state (zip_code.state) of the member whose position is President (member.position = 'President').\n To macth and combine the members of the club with the zip_code information details such as city and state, joining member table and zip_code table is required. Since zip column in member references to the zip_code column in the zip_code table, the joining operation can be done on the zip column of the member table and the zip_code column of the zip_code table (member.zip = zip_code.zip_code).\n The position condition should be applied on the position column of the member table (member.position = 'President').\n The zip_code table's city zip_code.city) and state (zip_code.state) columns should be selected."
        },
        {
          "question_id": 831,
          "db_id": "superhero",
          "question": "What is Abomination's eye colour?",
          "evidence": "Abomination refers to superhero_name = 'Abomination'; eye colour refers to colour.colour where eye_colour_id = colour.id;",
          "SQL": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Abomination'",
          "difficulty": "simple",
          "question_enriched": "Please find the eye colour (superhero.eye_colour_id and colour.colour) of the superhero whose name is Abomination (superhero.superhero_name = 'Abomination').",
          "question_enriched_v2": "Please find the eye colour (superhero.eye_colour_id and colour.colour) of the superhero whose name is Abomination (superhero.superhero_name = 'Abomination').\n Join the superhero table and colour table in the database on superhero.eye_colour_id = colour.id. Apply the superhere name condition (superhero.superhero_name = 'Abomination'). Select the colour column of the colour table (colour.colour).",
          "enrichment_reasoning": "The Abomination refers to the name of a superhero. The name of a superhero can be found from the superhero_name column of the superhero table in the database.\n The id of the eye colour of a superhero can be found from the eye_colour_id column of the superhero table in the database.\n The colour can be found from the colour column of the colour table (colour.colour).\n It is asked to find the eye colour of the superhero whose name is Abomination. \n To find the name of the eye colour of a superhero, the superhero table and the colour table should be joined on superhero.eye_colour_id = colour.id since eye_colour_id in the superhero table references to the id column of the colour table.\n After the superhere name condition (superhero.superhero_name = 'Abomination') be applied, the colour column of the colour table (colour.colour) should be selected for the correct answer."
        },
        {
          "question_id": 1163,
          "db_id": "thrombosis_prediction",
          "question": "What was the age of the youngest patient when they initially arrived at the hospital?",
          "evidence": "age refers to SUBTRACT(YEAR(`First Date`),YEAR(Birthday))",
          "SQL": "SELECT MIN(STRFTIME('%Y', `First Date`) - STRFTIME('%Y', Birthday)) FROM Patient",
          "difficulty": "simple",
          "question_enriched": " Please find the age (STRFTIME('%Y', Patient.`First Date`) - STRFTIME('%Y', Patient.Birthday)) of the youngest (MIN(age)) patient when patients arrived at the hospital initially (Patient.'First Date').",
          "question_enriched_v2": "Please find the age (STRFTIME('%Y', Patient.`First Date`) - STRFTIME('%Y', Patient.Birthday)) of the youngest (MIN(age)) patient when patients arrived at the hospital initially (Patient.'First Date').\n Since there is no condition, so no need for the WHERE clause in the SQL statement. All information can be found from the Patient table in the database.\n Ages of all patients can be calculated in the SELECT clause using MIN aggregate function and STRFTIME for extracting the year from the date information. ",
          "enrichment_reasoning": "The age information of a patient can be calculated from the his/her birthday. The birthday information of a patient can be found from the Birthday column of the Patient table in the database.\n The age of all patients should be calculated when they are first arrived (first data) at the hospital.\n To calculate the age of a patient when the patient arrived at the hospital, the first enterence date information is required. The first date information can be found from the 'First Date' column of the Patient table in the database.\n The age of a patient can be calculated by substracting the birthday of the patient (STRFTIME('%Y', Patient.Birthday)) from the first arrival date of the patient to the hospital in terms of the year (STRFTIME('%Y', Patient.`First Date`)).\n It is asked to find the age of the youngest patient when patients arrived (first date) at the hospital initially.\n Since there is no condition, so no need for the WHERE clause in the SQL statement. All information can be found from the Patient table in the database.\n Ages of all patients can be calculated in the SELECT clause using MIN aggregate function and STRFTIME for extracting the year from the date information. So, age is calculated as STRFTIME('%Y', Patient.`First Date`) - STRFTIME('%Y', Patient.Birthday)"
        },
        {
          "question_id": 339,
          "db_id": "toxicology",
          "question": "List the atom ID of the carcinogenic molecule that contains oxygen?",
          "evidence": "label = '+' mean molecules are carcinogenic; oxygen refers to element = 'o'",
          "SQL": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'o' AND T2.label = '+'",
          "difficulty": "simple",
          "question_enriched": "Please find the atom ID (atom.atom_id) of the molecule which is carciogenic (molecule.label = '+') and contains oxygen element (atom.element = 'o').",
          "question_enriched_v2": "Please find the atom ID (atom.atom_id) of the molecule which is carciogenic (molecule.label = '+') and contains oxygen element (atom.element = 'o').\n Join the molecule and atom tables on molecule_id columns of both table. Apply carcinogenic label condition (molecule.label = '+') and condition of containing oxygen element (atom.element = 'o'). Select atom ID (atom.atom_id).",
          "enrichment_reasoning": "The label in the database refers whether a molecule is carciogenic or not. The label information of a molecule can be found from the label column of the molecule table in the database. For a molecule, to be carciogenic, it's label should be '+'.\n The element information can be found from the element column of the atom table in the database. The oxygen is an element and it is expressed as 'o' as a value in the element column of the atom table in the database.\n It is asked to find the atom ID (atom.atom_id) of the molecule which is carciogenic (molecule.label = '+') and contains oxygen element (atom.element = 'o').\n To match and combine the molecule and atom information, the molecule and atom table should be joined. Since molecule_id column of the atom table references to the molecule_id column of the molecule table, the joining operations should be performed on the molecule_id column of both table.\n After applying carcinogenic label condition (molecule.label = '+') and condition of containing oxygen element (atom.element = 'o'), the atom ID (atom.atom_id) should be selected. "
        }
    ],
    "moderate": [
        {
          "question_id": 4,
          "db_id": "california_schools",
          "question": "Please list the phone numbers of the direct charter-funded schools that are opened after 2000/1/1.",
          "evidence": "Charter schools refers to `Charter School (Y/N)` = 1 in the frpm",
          "SQL": "SELECT T2.Phone FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Charter Funding Type` = 'Directly funded' AND T1.`Charter School (Y/N)` = 1 AND T2.OpenDate > '2000-01-01'",
          "difficulty": "moderate",
          "question_enriched": "Please find the phone numbers (schools.Phone) of the schools which are charter schools (frpm.`Charter School (Y/N)` = 1) and whose charter funding type is directly funded (frpm.`Charter Funding Type` = 'Directly funded') and OpenDate is later than 2000-01-01 (schools.OpenDate > '2000-01-01').",
          "question_enriched_v2": "Please find the phone numbers (schools.Phone) of the schools which are charter schools (frpm.`Charter School (Y/N)` = 1) and whose charter funding type is directly funded (frpm.`Charter Funding Type` = 'Directly funded') and OpenDate is later than 2000-01-01 (schools.OpenDate > '2000-01-01'). \n Join the frpm and schools tables. Since CDSCode column of frpm table references to CDSCode column of schools table, joining operation should be performed on CDSCode column of both table. \n Apply the condition of  being charter school (frpm.`Charter School (Y/N)` = 1), charter funding type condition (frpm.`Charter Funding Type` = 'Directly funded') and opening data condition (schools.OpenDate > '2000-01-01'). \n Select the Phone column of the schools table.",
          "enrichment_reasoning": "In the question phone numbers of the direct charter-funded schools that are opened after 2000/1/1 which is a date. The phone number information of schools can be found from the Phone table of the schools table in the database. \n The opening date information of the schools can be found from the OpenDate column of the schools table in the database. \n The information whether a school is direct charter-funded or not can be found from the `Charter Funding Type` table of the frpm table in the database. \n t is asked to list the phone numbers of the direct charter-funded schools that are opened after 2000-01-01. \n To combine and match the information in frpm table and schools table, join the frpm and schools tables. Since CDSCode column of frpm table referencing to the CDSCode column of schools table, joining operation should be performed on CDSCode column of both table. \n After appying being charter school condition (frpm.`Charter School (Y/N)` = 1), charter funding type condition (frpm.`Charter Funding Type` = 'Directly funded') and opening data condition (schools.OpenDate > '2000-01-01'), select the Phone column of the schools table."
        },
        {
          "question_id": 37,
          "db_id": "california_schools",
          "question": "What is the complete address of the school with the lowest excellence rate? Indicate the Street, City, Zip and State.",
          "evidence": "Execellence Rate = NumGE1500 / NumTstTakr; complete address has Street, City, State, Zip code",
          "SQL": "SELECT T2.Street, T2.City, T2.State, T2.Zip FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY CAST(T1.NumGE1500 AS REAL) / T1.NumTstTakr ASC LIMIT 1",
          "difficulty": "moderate",
          "question_enriched": "Please find the Street, City, Zip and State (schools.Street, schools.City, schools.State, schools.Zip) of the school which has the lowest excellence rate (min excellence rate) which is equal to NumGE1500 divided by NumTstTakr (satscores.NumGE1500 / satscores.NumTstTakr). \n To find the school with the lowest excellence rate, order entities with respect to excellence rate ascendingly and apply limit to return the lowest entity.",
          "question_enriched_v2": "Please find the Street, City, Zip and State (schools.Street, schools.City, schools.State, schools.Zip) of the school which has the lowest excellence rate (min excellence rate) which is equal to NumGE1500 divided by NumTstTakr (satscores.NumGE1500 / satscores.NumTstTakr).\n Join the satscores and schools tables on cds column of satscores table and CDSCode column of schools table (satscores.cds = schools.CDSCode). \n Calculate and order according to excellence rate (satscores.NumGE1500 / satscores.NumTstTakr) of each entity.\n Limit the resulting entities by 1 to find the minimum. \n Select the Street, City, State and Zip columns of the schools table.",
          "enrichment_reasoning": "In the question complete address means Street, City, State, Zip cod information of school. \n The excellence rate information of the schools should be calculated. In the evidence, it is given that excellence rate is equal to NumGE1500 divided by NumTstTakr. So, to calculate excellence rate NumGE1500 and NumTstTakr informations are required. \n The NumGE1500 information can be found from the NumGE1500 column in satscore table in the database. \n The NumTstTakr information can be found from the NumTstTakr column in satscore table in the database. \n The street, city, zip and state information of the school can be found from the Street, City, Zip and State columns in schools table in the database. \n It is asked to find the Street, City, Zip and State of the schools which has the lowest lowest excellence rate (min excellence rate) which is equal to NumGE1500 divided by NumTstTakr. \n To combine and the information about the satscores of schools and the their general school information, joining both satscore and schools table is required. Since the cds column of the satscores table references to the CDSCode column of the schools table, joining operation should be performed on cds column of satscores table and CDSCode column of schools (satscores.cds = schools.CDSCode). \n After ordering schools according to their excellence rate (which is calculated as satscores.NumGE1500 / satscores.NumTstTakr), the Street, City, State and Zip columns should be selected from the schools table."
        },
        {
          "question_id": 345,
          "db_id": "card_games",
          "question": "For artifact type of cards that do not have multiple faces on the same card, state its legalities status for vintage play format.",
          "evidence": "Artifact type of cards refers to types = 'Artifact'; card does not have multiple faces on the same card refers to side is NULL'; vintage play format refers to format = 'vintage';",
          "SQL": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.type = 'Artifact' AND T2.format = 'vintage' AND T1.side IS NULL",
          "difficulty": "moderate",
          "question_enriched": "Please find the legalities status (legalities.status) of the cards whose play format is vintage (legalities.format = 'vintage'), type is artifact (cards.types = 'Artifact') and that do not have multiple faces on the same card (cards.side IS NULL).",
          "question_enriched_v2": "Please find the legalities status (legalities.status) of the cards whose play format is vintage (legalities.format = 'vintage'), type is artifact (cards.types = 'Artifact') and that do not have multiple faces on the same card (cards.side IS NULL).\n Join the cards table and legalities table to see all the required information for a card that meets given conditions. Apply the conditions (cards.types = 'Artifact', legalities.format = 'vintage', cards.side IS NULL) and select distinct legalities.status column ",
          "enrichment_reasoning": "The type of cards can be found from the types column cards table in the database.\n The information of having multiple faces on the same card can be found from the side column of the cards table in the database.\n The legalities status of a card can be found from the status column of the legalities table in the database.\n The play format of the cards can be found from the format column of the legalities table in the database. \n It is asked to find the legalities status of the cards whose play format is vintage, type is artifact and that do not have multiple faces on the same card.\n To see all these information (type, having multiple faces on the same card, legalities status and play format) for a card can be found by joining cards table and legalities table of the database.\n After appying conditions (cards.types = 'Artifact', legalities.format = 'vintage', cards.side IS NULL), distinct legalities.status should be selected."
        },
        {
          "question_id": 563,
          "db_id": "codebase_community",
          "question": "User No.3025 gave a comment at 20:29:39 on 2014/4/23 to a post, how many favorite counts did that post get?",
          "evidence": "user no. 3025 refers to UserId = '3025'; comment at 20:29:39 on 2014/4/23 refers to CreationDate = '2014/4/23 20:29:39.0'",
          "SQL": "SELECT T1.FavoriteCount FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T2.CreationDate = '2014-04-23 20:29:39.0' AND T2.UserId = 3025",
          "difficulty": "moderate",
          "question_enriched": "Please find the favorite count (posts.FavoriteCount) of the post on which is commented by the user whose id is 3025 (comments.UserId = 3025) at  20:29:39 on 2014/4/23 (comments.CreationDate = '2014/4/23 20:29:39.0')",
          "question_enriched_v2": "Please find the favorite count (posts.FavoriteCount) of the post on which is commented by the user whose id is 3025 (comments.UserId = 3025) at  20:29:39 on 2014/4/23 (comments.CreationDate = '2014/4/23 20:29:39.0').\n The posts and comments tables in the database should be joined on comments.PostId = posts.Id. After the conditions (comments.CreationDate = '2014/4/23 20:29:39.0' and comments.UserId = 3025) are applied, the posts.FavoriteCount should be selected.",
          "enrichment_reasoning": "The user no which refers to UserId can be found from the UserId colum of the comments. \n The information of creation date of a comment can be found from the CreationDate column of the comments table in the database.\n The information of favorite counts of a post can be found from the FavoriteCount column of the posts table in the database. To match the posts with its comments, joining posts table and comments table is required using comments.PostId = posts.Id.\n It is asked to find the the favorite counts of a post on which UserId = '3025' commented at 20:29:39 on 2014/4/23.\n The posts and comments tables in the database should be joined on comments.PostId = posts.Id. \n After the conditions (comments.CreationDate = '2014/4/23 20:29:39.0' and comments.UserId = 3025) are applied, the FavoriteCount column of the post table should be selected."
        },
        {
          "question_id": 1487,
          "db_id": "debit_card_specializing",
          "question": "Which LAM customer used the Euro as their currency and had the highest consumption in October 2013?",
          "evidence": "October 2013 refers to 201310 in the yearmonth.date",
          "SQL": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM' AND T2.Date = '201310' AND T1.Currency = 'EUR' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
          "difficulty": "moderate",
          "question_enriched": "Please find the customer who belongs to LAM custoerm segment (customer.Segment = 'LAM') and use Euro as currency(customers.Currency = 'Euro'), and that has highest consumption in October 2013(yearmonth.Date = '201310').",
          "question_enriched_v2": "Please find the customer who belongs to LAM custoerm segment (customer.Segment = 'LAM') and use Euro as currency(customers.Currency = 'Euro'), and that has highest consumption in October 2013(yearmonth.Date = '201310').\n Join the customers and yearmonth tables in the database on CustomerID columns. Apply conditions which are ustomers.Segment = 'LAM', customers.Currency = 'Euro' and yearmonth.Date = '201310'. Order entities by sum of consumptions descendingly. \n Limit the returned entity number as 1 to get the customer with the highest consumption and select the customers.CustomerID.",
          "enrichment_reasoning": "The LAM is a customer segment, and the customer segment information can be found from the Segment column of the customers table in the database. \n The information of currency used by customer can be found by Currency column of the customers table in the database.\n Consumption of a customer can be found from the Consumption column of the yearmonth table in the database.\n It is asked to find the user whose segment is LAM (customers.Segment = 'LAM') and uses Euro as currecy (customers.Currency = 'Euro') and who made highest consumption in October 2013 (yearmonth.Date = '201310')\n The customers and yearmonth tables in the database should be joined to find each customers consumption for a period of time. Tables can be joined on CustomerID.\n After the conditions(ustomers.Segment = 'LAM', customers.Currency = 'Euro' and yearmonth.Date = '201310') are applied, the entities should be ordered by descendingly according to sum of consumptions in that date (SUM(T2.Consumption)).\n Limiting the returned entities so that only 1 entity(row) will be returned, and selecting CustomerID from the customers table will give the LAM customer used the Euro as their currency and had the highest consumption in October 2013. "
        },
        {
          "question_id": 1067,
          "db_id": "european_football_2",
          "question": "Which teams have build up play passing more than 70? Please list their short names.",
          "evidence": "build up play passing refers to buildUpPlayPassing; buildUpPlayPassing > 70; short names refers to team_short_name;",
          "SQL": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlayPassing > 70",
          "difficulty": "moderate",
          "question_enriched": "Please list the short names of the teams (Team.team_short_names) that have build up play passing more than 70 (Team_Attributes.buildUpPlayPassing > 70).",
          "question_enriched_v2": "Please list the short names of the teams (Team.team_short_names) that have build up play passing more than 70 (Team_Attributes.buildUpPlayPassing > 70).\n Join the Team and Team_Attributes tables based on the  team_api_id. Apply the build up play passing condition (Team_Attributes.buildUpPlayPassing > 70). Select the team_short_name column of the Team table (Team.team_short_name).",
          "enrichment_reasoning": "The information of build up play passing can be found from the buildUpPlayPassing column of the Team_Attributes table in the database.\n The short names of the teams can be found from the team_short_name attribute of the Team table in the database.\n It is asked to list the short names of the teams that have build up play passing more than 70.\n Since short names of the teams and their build up play passing attribute are in different tables, Team and Team_Attributes tables in the database should be joined based on the team_api_id since team_api_id in the Team_Attributes refers to the team_api_id attribute in the Team table.\n After joining, condition (Team_Attributes.buildUpPlayPassing > 70) should be applied on buildUpPlayPassing column of the Team_Attributes table.\n Then, to list the short names of the teams that satisfy the condition, team_short_name attribute of the Team table (Team.team_short_name) should be selected. "
        },
        {
          "question_id": 188,
          "db_id": "financial",
          "question": "Among the accounts who have loan validity more than 24 months, list out the accounts that have the lowest approved amount and have account opening date before 1997.",
          "evidence": "",
          "SQL": "SELECT T1.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.duration > 24 AND STRFTIME('%Y', T2.date) < '1997' ORDER BY T1.amount ASC LIMIT 1",
          "difficulty": "moderate",
          "question_enriched": "Please find the account with lowest loan amount (loan.amount) among the ones that has loan duration more than 24 month (loan.duration < 24), and account opening date is before 1997 (STRFTIME('%Y', T2.date)).",
          "question_enriched_v2": "Please find the account with lowest loan amount (loan.amount) among the ones that has loan duration more than 24 month (loan.duration < 24), and account opening date is before 1997 (STRFTIME('%Y', T2.date)).\n Join the account and loan tables through account_id. Apply loan duration condition (loan.duration > 24) and opening date condition (STRFTIME('%Y', T2.date) < '1997'). Order entities by loan amount ascendingly (ORDER BY loan.amount ASC). Limit the entities so that single entity is returned (LIMIT 1). Select the account_id column of loan table (loan.account_id).",
          "enrichment_reasoning": "The fundamental information about the account can be found from the account table in the database.\n The loan validity information refers to the duration of the loan, and it can be found from the duration column of the loan table in the databse.\n The loan approved amount information for an account can be found from the amount column of the loan table in the database.\n The opening date information of an account can be found from the date column of the account table in the database.\n It is asked to find the accounts that have the lowest loan amount,  have loand duration more than 24 months and opening date is before 1997.\n To combine or match the account and loan information, the account and loan tables in the database should be joined through account_id columns of the both account and loan table since account_id columns in loan refers to the account_id column of the account table.\n The loan validity in other words loan duration condition (loan.duration > 24) and account opening date constraint (STRFTIME('%Y', T2.date) < '1997') should be applied.\n Since the lowest loan amount is asked, entities should be ordered by loan amount ascendingly (ORDER BY loan.amount ASC). \n And the limit should be applied on the returned entities so that the lowest loan amount is returned (LIMIT 1).\n Select the account_id column from the loan table (loan.account_id)"
        },
        {
          "question_id": 1002,
          "db_id": "formula_1",
          "question": "As of the present, what is the full name of the youngest racer? Indicate her nationality and the name of the race to which he/she first joined.",
          "evidence": "full name refers to forename+surname; Youngest racer = MAX(dob)",
          "SQL": "SELECT T1.forename, T1.surname, T1.nationality, T3.name FROM drivers AS T1 INNER JOIN driverStandings AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T2.raceId = T3.raceId ORDER BY JULIANDAY(T1.dob) DESC LIMIT 1",
          "difficulty": "moderate",
          "question_enriched": "Please find the forename (drivers.forename), surname (drivers.surname), nationality (drivers.nationality) of the youngest driver (MAX(dob)) and the name of the race (races.name) first joined by that younges driver. Races joined by drivers can be seen from the driverStandings table in the database.",
          "question_enriched_v2": "Please find the forename (drivers.forename), surname (drivers.surname), nationality (drivers.nationality) of the youngest driver and the name of the race (races.name) first joined by that younges driver.\n Races joined by drivers can be seen from the driverStandings table in the database. \n Join the drivers, driverStandings on driverId column of both driver and driverStandings table, and join races on raceId column of both races and driverStandings tables.\n Firstly order the entities descendingly with respect to date of birth of the drivers (drivers.dob) and then order ascendingly with respect to the date of the races (ORDER BY drivers.dob DESC, races.date ASC).\n Limit the returned entities so that only a single entity, which indicate the first race attended by the younges driver, will be returned.\n Select forename, surname, nationality column from the drivers table and the name column from the races table should be selected (SELECT drivers.forename, drivers.surname, drivers.nationality, races.name).",
          "enrichment_reasoning": "The forename and the surname (full name) of the drivers can be found from the forename column and surname column of the drivers table in the database. \n To find the youngest driver, either the age of the drivers or the date of birth of the drivers is required. The date of birth of a driver can be found from the dob column of the drivers table in the database.\n Races joined by a driver can be seen from the driverStandings table in the database.\n Name information of a race can be found from the name column of the races table in the database.\n The date information of races is required to find the race to which youngest racer first joined. The date information of a race can be found from the data column of the races table in the database.\n It is asked to find the full name (forename and surname), nationality of the younges racer, as of the present, and the name of the race first joined by him/her.\n To combine or match the driver information, race information and races attended by drivers information; it is required to join the drivers table, driverStanding tables and races table. \n The drivers table and driversStandings table can be joined on driverId column of both table. Then the races table can be joined on raceId column of the races table and raceId column of the driverStandings table.\n To find the youngest driver, the entities should be descendinly ordered with respect to date of birth of the drivers, and then to find the first race attended by him/her, entities should be ordered with respect to the date of races ascendingly (ORDER BY drivers.dob DESC, races.date ASC).\n The limit should be applied to return a single entity that indicate the first joined race of the youngest racer along with its forename, surname, and nationality.\n The forename, surname, nationality column from the drivers table and the name column from the races table should be selected."
        },
        {
          "question_id": 1317,
          "db_id": "student_club",
          "question": "Among the students from the Student_Club who attended the event \"Women's Soccer\", how many of them want a T-shirt that's in Medium size?",
          "evidence": "Women's Soccer is an event name; T-shirt that is in Medium size refers to t_shirt_size = 'Medium'",
          "SQL": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Women''s Soccer' AND T3.t_shirt_size = 'Medium'",
          "difficulty": "moderate",
          "question_enriched": "Plase find the number (COUNT) of member whose T-shirt size is Medium (member.t_shir_size = 'Medium') and who attended the event with the 'Women's Soccer' name (event.event_name = 'Women's Soccer').",
          "question_enriched_v2": "Plase find the number (COUNT) of member whose T-shirt size is Medium (member.t_shir_size = 'Medium') and who attended the event with the 'Women's Soccer' name (event.event_name = 'Women's Soccer').\n To find the details of attendee of each event, join the event table, attendance table and member table on event.event_id = attendance.link_to_event and attendance.link_to_member = member.member_id.\n Apply event name condition (event.event_name = 'Women's Soccer') and the T-shirt size condition (member.t_shir_size = 'Medium').\n Count the number of entities.",
          "enrichment_reasoning": "The 'Women's Soccer' refers to an event name, and name of the event can be found from the event_name column of the event table in the database. \n The t_shirt size information of a person can be found from the t_shirt_size column of the member table in the database.\n The members attending an event can be found be joining the event table with the attendance table. Since the link_to_event column of the attendance table (attendance.link_to_event) references to the event_id column of the event table (event.event_id), joining of these two tables can be done on link_to_event and event_id columns of attendance and event tables respectively.\n To find the detail information about the members attending an event, the members table should also be joined with attendance table. So, details about the participant of each event with event details can be found.\n It is asked to find the number of member whose T-shirt size is Medium and who attended the event with the 'Women's Soccer' name.\n The event name condition (event.event_name = 'Women's Soccer') and the T-shirt size condition (member.t_shir_size = 'Medium') should be applied.\n After that the number of entities should be count to return the correct answer. "
        },
        {
          "question_id": 761,
          "db_id": "superhero",
          "question": "Among the male superheroes, list the super hero names of superheroes with weight greater than the 79% average weight of all superheroes.",
          "evidence": "super hero names refers to superhero_name;male superheros refers to gender = 'Male';Calculation = weight_kg > MULTIPLY(AVG(weight_kg), 0.79)",
          "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = 'Male' AND T1.weight_kg * 100 > ( SELECT AVG(weight_kg) FROM superhero ) * 79",
          "difficulty": "moderate",
          "question_enriched": "Please list the ame(superhero.superhero_name) of the male superheros (superheros.gender_id and gender.gender = 'Male')  whose weight is larger then the 79% of the average weight of all superheros ( superheros.weight_kg > average_weight_sql*79/100).",
          "question_enriched_v2": "Please list the ame(superhero.superhero_name) of the male superheros (superheros.gender_id and gender.gender = 'Male')  whose weight is larger then the 79% of the average weight of all superheros ( superheros.weight_kg > average_weight_sql*79/100).\n The average weight of all superheros can be found from an another SQL statement. The 79% average weight of all superheroes can be found by multiplying the average weight of all superheros with 79 and dividing it by 100. \n Generate average_weight_sql which returns average weights of all superheros.\n Join the superhero table and the gender table on superhero.gender_id = gender.id. Apply the gender condition (gender.gender = 'Male') and the weight condition (superhero.weight > 0.79 * average_weight_sql).\n Select superhero.superhero_name.",
          "enrichment_reasoning": "The word 'male' in the question refers to the gender. The gender id information of a superhero can be found from the gender_id column of the superhero table in the database.\n Different kind of genders and their ids can be found from the gender table in the database.\n The name information of superheros can be found from the superhero_name column of the superhero table in the database. \n The weight information of superheros can be found from the weight_kg column of the superhero table in the database.\n The average weight of all superheros can be found from an another SQL statement.\n The 79% average weight of all superheroes can be found by multiplying the average weight of all superheros with 79 and dividing it by 100.\n It is asked to list the name(superhero.superhero_name) of the male superheros (superheros.gender_id and gender.gender) whose weight is larger then the 79% of the average weight of all superheros (average_weight_sql*79/100).\n To match or combine the gender information and the superhero information, the joining of the superhero table and the gender table is required. Since gender_id column in superhero table references to the id column in the gender table, the joining superhero and gender tables can be done on superhero.gender_id = gender.id.\n The average weight of all superheros can be found by an inner sql statement using AVG aggregate funtion on weight_kg column of the superhero table (AGG(superhero.weight_kg)).\n Then the gender condition (gender.gender = 'Male') and the weight condition (superhero.weight > 0.79 * average_weight_sql) should be applied.\n The names of the superheros should be selected as selecting superhero.superhero_name."
        },
        {
          "question_id": 1309,
          "db_id": "thrombosis_prediction",
          "question": "Please list a patient's platelet level if it is within the normal range and if he or she is diagnosed with MCTD.",
          "evidence": "PLT > 100 and PLT < 400 means platelet level is within the normal range; PLT < 100 and PLT > 400 means platelet level is not within the normal range; diagnosed with MCTD refers to Diagnosis = 'MCTD';",
          "SQL": "SELECT T2.PLT FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'MCTD' AND T2.PLT BETWEEN 100 AND 400",
          "difficulty": "moderate",
          "question_enriched": "It is asked to list the platelet level (Laboratory.PLT) of patients whose platelet level (Laboratory.PLT) is within the normal range (Laboratory.PLT BETWEEN 100 AND 400) and who has MCTD diagnose (Patient.Diagnosis = 'MCTD').",
          "question_enriched_v2": "It is asked to list the platelet level (Laboratory.PLT) of patients whose platelet level (Laboratory.PLT) is within the normal range (Laboratory.PLT BETWEEN 100 AND 400) and who has MCTD diagnose (Patient.Diagnosis = 'MCTD').\n Join the Patient and Laboratory on ID column of both tables. Apply diagnose condition (Patient.Diagnosis = 'MCTD') and platelet level condition (Laboratory.PLT BETWEEN 100 AND 400). Select platelet level (Laboratory.PLT).",
          "enrichment_reasoning": "The platelet level of a patient can be found from the PLT column of the Laboratory table in the database.\n The normal platelet level (Laboratory.PLT) is in the range between 100 and 400 other wise it is not withing the normal level. In other words, normal platelet level (Laboratory.PLT) is in the range of 100 < Laboratory.PLT < 400\n The information of whether a patient is diagnosed with MCTD or not can be found from the Diagnosis column of the Patient table in the database. If the value of Diagnosis column in the Patient table is 'MCTD', (Patient.Diagnosis = 'MCTD') then it means that corresponding patient is diagnosed with MCTD.\n It is asked to list platelet level (Laboratory.PLT) of patients whose platelet level (Laboratory.PLT) is within the normal range (Laboratory.PLT BETWEEN 100 AND 400) and who has MCTD diagnose (Patient.Diagnosis = 'MCTD').\n To match and combine the laboratory results of a patient with detailed information about the patient, it is required to join Patient and Laboratory tables on ID column of the both table.\n After the diagnose condition (Patient.Diagnosis = 'MCTD') and platelet level condition (Laboratory.PLT BETWEEN 100 AND 400) is applied, the platelet (Laboratory.PLT) level should be selected."
        },
        {
          "question_id": 320,
          "db_id": "toxicology",
          "question": "What is the type of the bond which is presenting the connection between two atoms TR000_1 and TR000_2?",
          "evidence": "type of bond refers to bond_type; double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';",
          "SQL": "SELECT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_1' AND T2.atom_id2 = 'TR000_2'",
          "difficulty": "moderate",
          "question_enriched": "Please find the bond type (bond.bond_type) of the bond which connects two atoms whose atom IDs are TR000_1 (connected.atom_id = 'TR000_1') and TR000_2 (connected.atom_id = 'TR000_2').",
          "question_enriched_v2": "Please find the bond type (bond.bond_type) of the bond which connects two atoms whose atom IDs are TR000_1 (connected.atom_id = 'TR000_1') and TR000_2 (connected.atom_id = 'TR000_2').\n Join bond and connected tables on bond_id column of both table. Apply the condition that shows the connected atoms using their atom_id (connected.atom_id = 'TR000_1' AND connected.atom_id = 'TR000_2'). Select bond type (bond.bond_type). ",
          "enrichment_reasoning": "The information of bond type can be found from the bond_type column of the bond table in the database. \n The information about the connection between two atoms can be found from the table named connected in the database.\n It is asked to find the bond type (bond.bond_type) of the bond which represents connection between two atoms whose atom IDs are TR000_1 (connected.atom_id = 'TR000_1') and TR000_2 (connected.atom_id = 'TR000_2'). \n In order to combine and match the bond information and two atom connection information, joining bond table and connected table is required. Since the bond_id column of the connected table references to the bond_id column of the bond table, the joining of both table should be done on bond_id columns of both table.\n After appling the condition that restricts connected atoms (connected.atom_id = 'TR000_1' AND connected.atom_id = 'TR000_2'), bond type (bond.bond_type) should be selected."
        }
    ],
    "challanging": [
        {
          "question_id": 36,
          "db_id": "california_schools",
          "question": "Under whose administration is the school with the highest number of students scoring 1500 or more on the SAT? Indicate their full names.",
          "evidence": "full name means first name, last name; There are at most 3 administrators for each school; SAT Scores are greater or equal to 1500 refers to NumGE1500",
          "SQL": "SELECT T2.AdmFName1, T2.AdmLName1, T2.AdmFName2, T2.AdmLName2, T2.AdmFName3, T2.AdmLName3 FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
          "difficulty": "challenging",
          "question_enriched": "Please find the full name of the administrators (schools.AdmFName1, schools.AdmLName1, schools.AdmFName2, schools.AdmLName2, schools.AdmFName3, schools.AdmLName3) of the school with the highest NumGE1500 (ORDER satscores.NumGE1500 DESC LIMIT 1).",
          "question_enriched_v2": "Please find the full name of the administrators (schools.AdmFName1, schools.AdmLName1, schools.AdmFName2, schools.AdmLName2, schools.AdmFName3, schools.AdmLName3) of the school with the highest NumGE1500 (ORDER satscores.NumGE1500 DESC LIMIT 1). \n Join the satscores and schools table on cds column of satscores table and CDSCode column of schools table (satscores.cds = schools.CDSCode). \n Order the entities descendingly according to NumGE1500 column of the satscores table. \n Limit the resulting entities by 1. \n Select the administrators full names (schools.AdmFName1, schools.AdmLName1, schools.AdmFName2, schools.AdmLName2, schools.AdmFName3, schools.AdmLName3).",
          "enrichment_reasoning": "There are at most 3 administrators and their full name (first name and last name) can be found from the AdmFName1, AdmLName1, AdmFName2, AdmLName2, AdmFName3, AdmLName3 columns of the schools table. \n Number of students that score 1500 or more on the SAT exam can be found from the NumGE1500 column of the satscores table. \n To find the administrators of the school with the highest number of students scoring 1500 or more on the SAT; satscores and schools tables should be joined, entities should be ordered by NumGE1500 ascendingly and first entity should be selected with applying LIMIT 1, then AdmFName1, AdmLName1, AdmFName2, AdmLName2, AdmFName3, AdmLName3 columns should be selected."
        },
        {
          "question_id": 83,
          "db_id": "california_schools",
          "question": "Of the schools that offers a magnet program serving a grade span of Kindergarten to 8th grade, how many offers Multiple Provision Types? List the number of cities that offers a Kindergarten to 8th grade span and indicate how many schools are there serving such grade span for each city.",
          "evidence": "Kindergarten to 8th grade refers to K-8; 'Offers a magnet program' means Magnet = 1; Multiple Provision Types refers to `NSLP Provision Status` = 'Multiple Provision Types'",
          "SQL": "SELECT T2.City, COUNT(T2.CDSCode) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.Magnet = 1 AND T2.GSoffered = 'K-8' AND T1.`NSLP Provision Status` = 'Multiple Provision Types' GROUP BY T2.City",
          "difficulty": "challenging",
          "question_enriched": "For each city, please find the number of schools (COUNT(schools.CDSCODE)) offering magnet program (schools.Magnet = 1) to grade span of Kindergarten to 8th grade (schools.GSoffered = 'K-8') and offering Multiple Provision Types in NSLP Provision Status (frpm.`NSLP Provision Status` = 'Multiple Provision Types').",
          "question_enriched_v2": "For each city, please find the number of schools (COUNT(schools.CDSCODE)) offering magnet program (schools.Magnet = 1) to grade span of Kindergarten to 8th grade (schools.GSoffered = 'K-8') and offering Multiple Provision Types in NSLP Provision Status (frpm.`NSLP Provision Status` = 'Multiple Provision Types'). \n Join frpm and schools tables on CDSCode column of the both table. \n Apply the magnet program condition (schools.Magnet = 1) , the GSoffered condition (schools.GSoffered = 'K-8'), and the NSLP Provision Status condition (frpm.`NSLP Provision Status` = 'Multiple Provision Types'). \n Group entities according to cities (GROUP BY schools.City).  \n Select the city (schools.City) and calculate schools with the COUNT aggregation function (COUNT(schools.CDSCode).",
          "enrichment_reasoning": "The information of whether a school offers a magnet program or not can be found from the Magnet column of the schools table in the database. \n Grade span is given as Kindergarten to 8th grade (K-8). The GSoffered column in the schools table refers to offered grade span. So, the information of shool program serving to a K-8, can be found from the GSoffered column in the schools table in the database. \n The information of whether a school offers Multiple Provision Types or not can be found from the NSLP Provision Status` column of the frpm table. \n It is asked to find the number of schools that offers a magnet program serving to a grade span of Kindergarten to 8th grade and that provides Multiple Provision Types for each city. \n To find the schools that offers a magnet program serving to a grade span of Kindergarten to 8th grade (K-8) and also provides Multiple Provisioning Types, frpm tables and schools tabels should be joined. \n The magnet program condition (schools.Magnet = 1), GSoffered to K-8 condition (schools.GSoffered = 'K-8') and the NSLP Provision Status condition (frpm.`NSLP Provision Status` = 'Multiple Provision Types') should be applied. Then, the entities should be grouped according to cities (schools.City). Finaly, the city should be selected (schools.City) and number of school should be found with count aggregation function (COUNT(schools.CDSCode))."
        },
        {
          "question_id": 506,
          "db_id": "card_games",
          "question": "For all the set of cards that has Japanese translation, what is the percentage of them are only available in non-foil?",
          "evidence": "Japanese translation refers to language = 'Japanese'; in non-foil refers to isNonFoilOnly = 1; percentage of Japanese non foil in Japanese cards refers to DIVIDE(SUM(isNonFoilOnly = 1), SUM(language = 'Japanese'))*100",
          "SQL": "SELECT CAST(SUM(CASE WHEN isNonFoilOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Japanese' )",
          "difficulty": "challenging",
          "question_enriched": "Please find the percentage of the set of cards that are only available in non-foil (sets.isNonFoilOnly = 1) for the sets of cards that has Japanese translation(set_translations.language = 'Japanese').",
          "question_enriched_v2": "Please find the percentage of the set of cards that are only available in non-foil (sets.isNonFoilOnly = 1) for the sets of cards that has Japanese translation(set_translations.language = 'Japanese').\n Codes of the all set of cards that has Japanese translation can be found by applying the condition language = 'Japanese' on the set_translations table.\n The percentage of sets of card that are only available in non-foil should be calcuted for the entities whose code value is in the codes of the all set of cards that has Japanese translation. \n The percentage can be calculated by dividing the number of sets of card that are only available in non-foil by total number of sets. \n The number of sets of card that are only available in non-foil can be found by using SUM aggregate function with CASE WHEN expression and then casting it to real number.",
          "enrichment_reasoning": "The information of having Japanese translation for a set of card can be found from language column of the set_translations table in the database. \n The information of whether a set of card is only available in non-foil or not can be found from the isNonFoilOnly column of the sets table in the database.\n It is asked to find the percentage of the set of cards that are only available in non-foil for the set of cards that has Japanese translation.\n Initially the codes of the all set of cards that has Japanese translation should be found by appying the condition language = 'Japanese' on set_translations table.\n Then the percentage of sets of card that are only available in non-foil should be calcuted for the entities whose code value is in the codes of the all set of cards that has Japanese translation which is already found.\n The percentage can be calculated by dividing the number of sets of card that are only available in non-foil by total number of sets that has Japanese translation.\n The number of sets of card that are only available in non-foil can be found by using SUM aggregate function with CASE WHEN expression and then casting it to real number."
        },
        {
          "question_id": 701,
          "db_id": "codebase_community",
          "question": "Among all the posts posted by the most influential user, identify the percentage with a score above 50.",
          "evidence": "The higher reputation the user has the more influence; percentage = DIVIDE(COUNT(stats_posts.Id where Score > 50 and MAX(Reputation))), COUNT(stats_posts.Id where MAX(Reputation));",
          "SQL": "SELECT CAST(SUM(CASE WHEN T2.Score > 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id) FROM users T1 INNER JOIN posts T2 ON T1.Id = T2.OwnerUserId INNER JOIN ( SELECT MAX(Reputation) AS max_reputation FROM users ) T3 ON T1.Reputation = T3.max_reputation",
          "difficulty": "challenging",
          "question_enriched": "Please find the percentage of the posts whose score is larger than 50 (posts.score > 50) among the posts of the user who has largest reputation.",
          "question_enriched_v2": "Please find the percentage of the posts whose score is larger than 50 (posts.score > 50) among the posts of the user who has largest reputation.\n First find the maximum reputation score among users. Then find the posts of the user who has the highest reputation by joining necessary tables.\n Calculate the percentage of the posts whose score above 50 among the posts of the user with highest reputation. CASE WHEN expression may help you to calculate percentage.",
          "enrichment_reasoning": "Reputation information of a user can be found from the Reputation column of the users table in the database. \n Score information of a post can be found from the Score column of the posts table. \n It is asked to find the percentage of the posts whose score above 50 among the posts of most influential user.\n To find the posts of the most influential user, we need to find the maximum reputation score among users. So, we need to create a simple SQL using MAX(Reputation) aggregation funtion.\n After that to find the most influential user, we need to join the users table with the single valued SQL that generates maximum reputation score. Joining process should be based-on reputation.\n Posts of a user can be matched with joining users table with posts on user id (users.Id = posts.OwnerUserId). \n Upto now, posts of the most influential user can be found with joining necessary tables and queries resulting a maximum reputation score for users.\n The percentage of the posts whose score above 50 among the posts of the most influential user can be calculated by dividing the number of those post whose score larger than 50 by the number of posts of most influential user.\n The number of posts whose score larger than 50 can be calculated with SUM aggregate function with CASE WHEN expression which increments the count by 1 if the post score larger than 50.\n This percentage calculation using CAST, SUM and CASE WHEN expressions should be written in SELECT clause in the SQL."
        },
        {
          "question_id": 1482,
          "db_id": "debit_card_specializing",
          "question": "Which of the three segments\u2014SME, LAM and KAM\u2014has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013?",
          "evidence": "Increase or Decrease = consumption for 2013 - consumption for 2012; Percentage of Increase = (Increase or Decrease / consumption for 2013) * 100%; The first 4 strings of the Date values in the yearmonth table can represent year",
          "SQL": "SELECT CAST((SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0))) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)), CAST(SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) , CAST(SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID",
          "difficulty": "challenging",
          "question_enriched": "Please calculate the percentage increase or decrese in consumption paid in EUR(customer.Currency = 'EUR') between 2012 (yearmonth.Date = '2013%') and 2013 (yearmonth.Date = '2013%').\n The percentage increase or decrease in consumption between 2012 and 2013 can be calculated as ((consumption for 2013 - consumption for 2012) / consumption for 2012).\n The total consumption for 2013 for SME customer segment can be calculated as SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)).",
          "question_enriched_v2": "Please calculate the percentage increase or decrese in consumption paid in EUR(customer.Currency = 'EUR') between 2012 (yearmonth.Date = '2013%') and 2013 (yearmonth.Date = '2013%').\n The percentage increase or decrease in consumption between 2012 and 2013 can be calculated as ((consumption for 2013 - consumption for 2012) / consumption for 2012).\n Join the yearmonth and customers table using CustomerID column. Then calculate percentage increase or decrease in consumption between 2012 and 2013 for each customer segment (SME, LAM and KAM).\n As an example, the total consumption for 2013 for SME customer segment can be calculated as SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)). \n As an example, the percentage increase or decrease in consumption for SME customer segment can be calculated as CAST((SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0))) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0))",
          "enrichment_reasoning": "The customer segment information can be fromt he Segment column of the customers table in the database.\n The consumption information of each customer can be found from the Consumption column of the yearmonth table in the database.\n The date of the consumption of each customer information can be found from the Date column of the yearmonth table.\n The information of currency used by customer can be found from the Currency column of the customers table in the database.\n Although is asked to find the customer segment that has the lowest and bigest percentage increase in consumption paid in EUR between 2012 and 2013. \n It is enough to return percentage increase or decrease in consumption in EUR for each customer segment (SME, LAM, KAM) to see which has the lowest and which has the biggest increase in consumption.\n To see the consumption of each customer in each month of each year, it is required to join the customers and yearmonth tables where CustomerID in yearmonth table refers to CustomerID in costomer table.\n After that calcuate percentage increase or decrease in consumption for each customer segment asked (SME, LAM and KAM). \n To calculate the percentage increase or decrease in consumption for a segment, total consumption in 2012 should be substructed from the total consumption in 2013 for a specific customer segment. Then the difference should be divided by the total consumption in 2012 made by that customer segment.\n Since the values of the Date column in the yearmonth table are in the format of text and represented as 'yearmonth' format, the first 4 strings of the Date values represents year and % would help to find the all months of a year.\n IFF(X, Y, Z) function, which generates the same bytecode as the CASE expression 'CASE WHEN X THEN Y ELSE Z END', can be used. \n CAST((SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0))) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)) is the example of how to calculate percentage increase of decrease in consumption for a SME custoemr segment."
        },
        {
          "question_id": 1115,
          "db_id": "european_football_2",
          "question": "What percentage is Landon Donovan's overall rating higher than Jordan Bowery on 2013/7/12?",
          "evidence": "Landon Donovan's refers to player_name = 'Landon Donovan'; Jordan Bowery refers to player_name = 'Jordan Bowery'; percentage refers to DIVIDE(SUBTRACT(player_name = 'Landon Donovan' overall_rating; player_name = 'Jordan Bowery' overall_rating), player_name = 'Landon Donovan' overall_rating)*100",
          "SQL": "SELECT (SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Jordan Bowery' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) LvsJ_percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2013-07-12'",
          "difficulty": "challenging",
          "question_enriched": "Please find how much higher is London Donovan's (Player.player_name = 'London Donovan') overall rating is compared to Jordan Bowery's (Player.player_name = 'Jordon Bowery'), on July 12, 2013 (SUBSTR(t2.`date`, 1, 10) = '2013-07-12'), expressed as percentage (percentage can be calculated as the dividing the difference between the overall rating of Landon Donavan and overall rating of the Jordan Bowery by overall rating of London Donovan and then multiply with 100). ",
          "question_enriched_v2": "Please find how much higher is London Donovan's (Player.player_name = 'London Donovan') overall rating is compared to Jordan Bowery's (Player.player_name = 'Jordon Bowery'), on July 12, 2013 (SUBSTR(t2.`date`, 1, 10) = '2013-07-12'), expressed as percentage (percentage can be calculated as the dividing the difference between the overall rating of Landon Donavan and overall rating of the Jordan Bowery by overall rating of London Donovan and then multiply with 100). \n Join the Player and Player_Attributes table based on the player_api_id or player_fifa_api_id. Then, apply date condition (SUBSTR(t2.`date`, 1, 10) = '2013-07-12'). \n Using CASE WHEN expressions, calculate overall rating values of given players with the help of SUM aggregation function. Then, calculate the percentage in the SELECT clause.",
          "enrichment_reasoning": "The overall rating of a player can be found from the overall_rating column of the Player_Attributes table in the database.\n The overall rating of a player on a specific data can be found from the overall_rating column of the Player_Attributes table after applying the date condition on the date column of the Player_Attributes table in the database.\n Both Landon Donovan and Jordan Bowery refores to player name which can be found from the player_name column of the Player table. \n The percentage can be expressed as the dividing the difference between the overall rating of Landon Donavan and overall rating of the Jordan Bowery by overall rating of London Donovan and then multiply with 100.\n It is asked to determine the percentage difference between Landon Donovan's overall rating and Jordan Bowery's overall rating on July 12, 2013. How much higher is Landon Donovan's rating compared to Jordan Bowery's, expressed as a percentage?\n To find the attributes of each players, joining the Player and Player_Attributes tables based on player_api_id or player_fifa_api_id is required. \n The date condition should be applied on the date column of the Player_Attributes table (Player_Attributes.date). Note that the date attribute values in Team_Attributes table are in text form ('year-mounth-day'). So, the first 10 character should be '2013-07-13', (WHERE SUBSTR(t2.`date`, 1, 10) = '2013-07-12').\n After joining and applying conditions, we know the attributes of each player on that day. Using CASE WHEN expressions, overall rating values of given players can be calculated with the help of SUM aggregation function. Then the percentage calculation should be performed in SELECT clause."
        },
        {
          "question_id": 173,
          "db_id": "financial",
          "question": "How often does account number 3 request an account statement to be released? What was the aim of debiting 3539 in total?",
          "evidence": "k_symbol refers to the purpose of payments",
          "SQL": "SELECT T1.frequency, T2.k_symbol FROM account AS T1 INNER JOIN (SELECT account_id, k_symbol, SUM(amount) AS total_amount FROM `order` GROUP BY account_id, k_symbol) AS T2 ON T1.account_id = T2.account_id WHERE T1.account_id = 3 AND T2.total_amount = 3539",
          "difficulty": "challenging",
          "question_enriched": "Please find the frequency of the account (account.frequency) and the purpose (order.k_symbol) of the debitting 3539 in total for the account whose number is 3 (account.account_id = 3).",
          "question_enriched_v2": "\n Please find the frequency of the account (account.frequency) and the purpose (order.k_symbol) of the debitting 3539 in total for the account whose number is 3 (account.account_id = 3). \n The column k_symbol refers to the purpose of payments.\n Create an inner SQL for generating a table to find the total debiting amount for each purpose of debiting for each account, and name it T. To create T; group entities of the order table based on account_id and k_symbol, select account_id, k_symbol and sum of amounts (total_amount) using SUM aggregate function.\n For the outer SQL, join account table with the table T. Apply total debiting amount condition (T.total_amount = 3539) and accoutn number condition (account.account_id = 3).\n Select frequency (account.frequency) and the purpose of debiting (T.k_symbol).",
          "enrichment_reasoning": "The question 'How often' refers to the frequency, and the frequency of the account can be found from the frequency column of the account table in the database.\n The account number can be found from the account_id column of the account table in the database.\n The k_symbol refers to the purpose, so the aim of debiting can be found from the k_symbol column of the order table in the database.\n The debiting amount for each order can be found from the amount column of the order table in the database.\n It is asked to find the frequency of the account and the purpose(k_symbol) of the debitting 3539 in total for the account whose account_id is 3.\n To find the total debiting amount for each purpose of debiting for each account; entities in order table should be grouped by account_id and k_symbol, and then account_id, k_symbol and sum of amounts using SUM aggregate function should be selected. Lets call this table as T, and call the sum of amounts as total_amount.\n To match or combine the account information with the table generated T, joining is required with the account table on account_id column of both table. \n The account number condition (account.account_id = 3) and the total debiting amount condition (T.total_amount = 3539) should be applied in WHERE clause of the outher SQL statement.\n The frequency (account.frequency) and the purpose of debiting (T.k_symbol) should be selected in SELECT clause."
        },
        {
          "question_id": 880,
          "db_id": "formula_1",
          "question": "Paul di Resta was in the No. 853 race, what percent faster did he finish in the 853rd race than the next race for the fastest lap speed?",
          "evidence": "Paul di Resta refers to the full name of the driver; Full name of the driver refers to drivers.forename ='Paul' and drivers.surname = 'di Resta'; race number refers to raceId; percentage = DIVIDE(SUBTRACT(fastestLapSpeed(raceId = 853), (fastestLapSpeed (raceId = 854)) * 100 , (fastestLapSpeed(raceId = 853))",
          "SQL": "SELECT (SUM(IIF(T2.raceId = 853, T2.fastestLapSpeed, 0)) - SUM(IIF(T2.raceId = 854, T2.fastestLapSpeed, 0))) * 100 / SUM(IIF(T2.raceId = 853, T2.fastestLapSpeed, 0)) FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T1.forename = 'Paul' AND T1.surname = 'di Resta'",
          "difficulty": "challenging",
          "question_enriched": "Please find the percentage difference indicating how much faster Paul di Resta (drivers.forename = 'Paul' and drivers.surname = 'di Resta') in the race with raceId 853 (results.raceId = 853) compared to the subsequent race with raceId 854 (results.raceId = 854) when fastest lap speed (results.fastestLapSpeed) considered.",
          "question_enriched_v2": "Please find the percentage difference indicating how much faster Paul di Resta (drivers.forename = 'Paul' and drivers.surname = 'di Resta') in the race with raceId 853 (results.raceId = 853) compared to the subsequent race with raceId 854 (results.raceId = 854) when fastest lap speed (results.fastestLapSpeed) considered.\n Join the drivers and resuts table on driverId attribute. Apply the driver forename and surname condition (drivers.forename = 'Paul' and drivers.surname = 'di Resta'). \n Calculate percentage based on fastest lap speed by dividing the difference between the fastestLapSpeed value in raceId = 853 and subsequent raceId=854 by the fastestLapSpeed value in raceId = 853 using IFF expression and then multiplying with the 100.",
          "enrichment_reasoning": "The forename and the surname of the driver can be found from the forename and surname columns of the drivers table.\n The forename of the driver is 'Paul' (drivers.forename ='Paul' )and the surname of the driver is 'di Resta' (drivers.surname = 'di Resta').\n Race No refers to the raceId.\n The fastest lap speed information can be found from the fastestLapSpeed column of the results table in the database.\n It is asked to find percentage difference indicating how much faster Paul di Resta in the race with raceId 853 compared to the subsequent race with raceId 854 when fastest lap speed considered.\n To combine and match the drivers information with their race results for each race, joining drivers table and the results table is required on driverId column of both drivers table and results table since results(driverId) refers to drivers(driverId).\n The forename, surname condition should be applied on drivers table as drivers.forename = 'Paul' AND drivers.surname = 'di Resta'. \n Because there is two different race exist as condition, IFF expression can be used to find fastest lap speed (results.fastestLapSpeed) for different races.\n The fastest lap speed for a given raceId can be found using IFF expression as (SUM(IIF(T2.raceId = <write raceID>, T2.fastestLapSpeed, 0))\n The percentage on fastest lap speed can be calculated as dividing the difference between the fastestLapSpeed value in raceId = 853 and subsequent raceId=854 by the fastestLapSpeed value in raceId = 853 and multiplying with the 100."
        },
        {
          "question_id": 1429,
          "db_id": "student_club",
          "question": "What is the name of the social event that was attended by the vice president of the Student_Club located at 900 E. Washington St.?",
          "evidence": "name of social event refers to event_name where type = 'Social'; 'Vice President' is position; located at refers to location",
          "SQL": "SELECT T2.event_name FROM attendance AS T1 INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id WHERE T3.position = 'Vice President' AND T2.location = '900 E. Washington St.' AND T2.type = 'Social'",
          "difficulty": "challenging",
          "question_enriched": "Please find the name (event.event_name) of the social event (event.type = 'Social') located at 900 E. Washington St. (event.location = '900 E. Washington St.') and that was attended (attendance) by the member whose position is vice president (member.position = 'Vice President').",
          "question_enriched_v2": "Please find the name (event.event_name) of the social event (event.type = 'Social') located at 900 E. Washington St. (event.location = '900 E. Washington St.') and that was attended (attendance) by the member whose position is vice president (member.position = 'Vice President').\n Join the ttendance table, event table and member table on attendance.link_to_event = event.event_id and attendance.link_to_member = member.member_id.\n Apply member position condition (member.position = 'Vice President'), event location condition (event.location = '900 E. Washington St.') and the event type condition (event.type = 'Social').\n Select the event_name column of the event table (event.event_name).",
          "enrichment_reasoning": "The name of the event can be found from the event_name column of the event table.\n Social event refers to the type of the event, and type information of the event can be found from te type column of the event table (event.type) in the database.\n The vice president is a position of a member, and position information of a member can be found from the position column of the member table (member.position) in the database.\n The location information of an event can be found from the location column of the event table (event.location) in the database.\n The attendees of an event can be found from the attendance table. If details of attendees or event is required, the member or event tables should be joined with the attendance table.\n It is asked to find the name (event.event_name) of the social event (event.type = 'Social') located at 900 E. Washington St. (event.location = '900 E. Washington St.') and that was attended by the member whose position is vice president (member.position = 'Vice President').\n To match the details of attendees and details of the events, the attendance table, event table and member table should be joined. Since link_to_event in attendance references to event_id column of event, joining attendance and event tables can be done on attendance.link_to_event = event.event_id. Since link_to_member column of attendance references to the member_id column of the member table, joining attendance and member table can be done on attendance.link_to_member = member.member_id.\n The member position condition (member.position = 'Vice President'), event location condition (event.location = '900 E. Washington St.') and the event type condition (event.type = 'Social') should be applied.\n The event_name column of the event table (event.event_name) should be selected for the correct answer."
        },
        {
          "question_id": 819,
          "db_id": "superhero",
          "question": "In superheroes with missing weight data, calculate the difference between the number of superheroes with blue eyes and no eye color.",
          "evidence": "missing weight data refers to weight_kg = 0 OR T1.weight_kg = NULL; difference = SUBTRACT(SUM(colour.id = 7), SUM(colour.id = 1)); blue eyes refers to eye_colour_id WHERE colour.id = 7; no eye color refers to eye_colour_id WHERE colour.id = 1;",
          "SQL": "SELECT SUM(CASE WHEN T2.id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.weight_kg = 0 OR T1.weight_kg is NULL",
          "difficulty": "challenging",
          "question_enriched": "For superheroes with missing weight data (superhero.weight_kg = 0 OR superhero.weight_kg IS NULL), calculate the difference in the number of superheroes with blue eyes (superhero.eye_colour_id = 7) compared to those with no recorded eye color (superhero.eye_colour_id = 1).",
          "question_enriched_v2": "For superheroes with missing weight data (superhero.weight_kg = 0 OR superhero.weight_kg IS NULL), calculate the difference in the number of superheroes with blue eyes (superhero.eye_colour_id = 7) compared to those with no recorded eye color (superhero.eye_colour_id = 1).\n Using CASE WHEN expression with SUM aggregate function in the SELECT clause for different cases would be helpful to calculate the number of superheroes with blue eyes and no eye color differently.\n After applying the missing weight data condition on the superhero table (superhero.weight_kg = 0 OR superhero.weight_kg IS NULL), the number of superheros with the no eye color SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) substracted from the number of superheros with the blue eye color SUM(CASE WHEN T2.id = 7 THEN 1 ELSE 0 END).",
          "enrichment_reasoning": "The weight information of the superheros can be found from the weight_kg column of the superhero table in the database. \n The missing weight data refers to superhero.weight_kg = 0 or superhero.weight_kg = NULL. \n The blue eyes colour id is given as 7 (superhero.eye_colour_id = 7). And the no eye colour id is given as 1 (superhero.eye_colour_id = 1). \n It is asked to find the difference between the number of superheroes with blue eyes (superhero.eye_colour_id = 7) and no eye color (superhero.eye_colour_id = 1) for the superheros with missing weight data. (superhero.weight_kg = 0 OR superhero.weight_kg IS NULL)\n Since there are two case which are superheroes with blue eyes and with no eye color, using CASE WHEN expression with SUM aggregate function in the SELECT clause for different cases would be helpful to calculate the number of superheroes with blue eyes and no eye color differently.\n The difference is given as the number of superheroes with no eye colour is substracted from the superheroes with blue eye colour, where in both case superheros have missing weight data  (superhero.weight_kg = 0 OR superhero.weight_kg IS NULL).\n After applying the missing weight data condition on the superhero table (superhero.weight_kg = 0 OR superhero.weight_kg IS NULL), the number of superheros with the no eye color SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) substracted from the number of superheros with the blue eye color SUM(CASE WHEN T2.id = 7 THEN 1 ELSE 0 END)"
        },
        {
          "question_id": 1223,
          "db_id": "thrombosis_prediction",
          "question": "Are there more male patients with creatinine not within the normal range than female? True or False?",
          "evidence": "creatinine (CRE) not within the normal range refers to CRE > = 1.5; male refers to Sex = 'M'; female refers to Sex = 'F'; calculation = (SUM(SEX = 'M') > SUM(SEX = 'F')) where CRE > = 1.5",
          "SQL": "SELECT CASE WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) THEN 'True' ELSE 'False' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5",
          "difficulty": "challenging",
          "question_enriched": "Please find whether the number of male patients (SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END)) whose creatinine level is not within the normal range (Laboratory.CRE > = 1.5) than the number of female patients (Patient.SEX = 'F') whose creatinine level is not within the normal range (SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END)) by returning only True or False.",
          "question_enriched_v2": "Please find whether the number of male patients (SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END)) whose creatinine level is not within the normal range (Laboratory.CRE > = 1.5) than the number of female patients (Patient.SEX = 'F') whose creatinine level is not within the normal range (SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END)) by returning only True or False.\n Join the Patient and Laboratory on ID column of both tables. Apply the creatinine level condition (Laboratory.CRE > = 1.5). Since comparison of two different value for a single attribute which is sex of patients is asked, it is useful to use CASE WHEN expression.\n With using SUM aggregate funtion and CASE WHEN expression, calculate the number of male (SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END)) and female (SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END)) patients whose creatinine level is not within the normal range (Laboratory.CRE > = 1.5). ",
          "enrichment_reasoning": "The sex information of a patient can be found from the SEX column of the Patient table in the database. The 'M' value in SEX column indicates male while 'F' value indicates female.\n The creatinine information of a patient can be found from the CRE column of the Laboratory table in the database. \n If a patient creatinine value (Laboratory.CRE) is equal to or above 1.5 (Laboratory.CRE > = 1.5), then it is not within the normal range.\n It is asked to find whether the number of male patients (Patient.SEX = 'M') whose creatinine level is not within the normal range (Laboratory.CRE > = 1.5) than the number of female patients (Patient.SEX = 'F') whose creatinine level is not within the normal range  (Laboratory.CRE > = 1.5) by returning only True or False.\n To match and combine the laboratory results of a patient with detailed information about the patient, it is required to join Patient and Laboratory tables on ID column of the both table.\n The creatinine level condition indicating not within the normal range (Laboratory.CRE > = 1.5) should be applied.\n Since comparison of two different value for a single attribute which is sex of patients is asked, it is useful to use CASE WHEN expression.\n With using SUM aggregate funtion and CASE WHEN expression, the number of male patients (SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END)) whose creatinine level is not within the normal range can be found . Similarly, with using SUM aggregate funtion and CASE WHEN expression, the number of female patients (SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END)) whose creatinine level is not within the normal range can be found\n Again using CASE WHEN expression by comparing the number of male and female patients, the correct result can be returned in the form of 'True' or  'False'."
        },
        {
          "question_id": 240,
          "db_id": "toxicology",
          "question": "List all the elements of the toxicology of the molecule \"TR004\".",
          "evidence": "TR004 is the molecule id;",
          "SQL": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR004'",
          "difficulty": "challenging",
          "question_enriched": "Please list all distinct elements (atom.element) in molecule with molecule id is TR004 (atom.molecule_id = 'TR004').",
          "question_enriched_v2": "Please list all distinct elements (atom.element) in molecule with molecule id is TR004 (atom.molecule_id = 'TR004').\n Apply condition specifiying molecule id (atom.molecule_id = 'TR004') on the atom table. Select distinct elements (DISTINCT atom.element) from the atom table.",
          "enrichment_reasoning": "The information of elements existing in a molecule can be found from the atom table in the database.\n The elements in a molecule can be found from the element column of the atom table.\n The molecule ID (molecule_id) information can be found from the molecule_id column of the atom table in the database (atom.molecule_id).\n It is asked to list the all elements (atom.element) of the molecule whose id is TR004 (atom.molecule_id = 'TR004')\n Since all required information can be found from a single table, there is no need for joining operations.\n The condition that specify the molecule id (atom.molecule_id = 'TR004') should be applied on atom table. \n All distinct elements should be selected from the atom table (DISTINCT atom.element)."
        }
    ]
}
